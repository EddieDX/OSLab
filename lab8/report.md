lab8 实验报告 2012011306
# 练习一 完成读文件操作的实现
这里主要要理解文件的读写都是按照块为单位执行的。
所以，我们读文件的目标为：sin这个inode中从offset到endpos这些位置所代表的block。

分为三个阶段
1 判断开头是否不满一个块的大小？如果是，调用buf_io操作
2 中间的块用buf_io操作
3 和开头一样，判断结尾是否不满一个block，是则调用buf_io

两个返回值ret返回是否操作成功，alen返回操作成功长度。

## PIPE机制设计方案
PIPE机制就是说，pipe的两端，互相不管对方是什么，只是一端读，一端写，所以就是一个inode上开两个不同权限的文件。

参考UCore中的实现，PIPE机制的设计思路如下：
1 创立接口pipefs，利用VFS机制提供的接口，这个fs是让pipe用的，同时创建两个file，一个有只读权限，一个有只写权限，然后两个file连接到一个inode上。
2 pipefs中的那个inode需要有一个数据缓冲区，用VFS提供的read/write接口负责数据在缓冲区的读写。
3 缓冲区需要有两个指针，head和tail，开始的时候两者重复，表示数据为空
4 这个inode还需要一个管程，同步读写

写的过程：不断循环，如果有东西要写，获取当前缓冲区内的空闲资源，如果空闲空间，写操作就让睡在该条件变量上的进程进行读操作，然后睡在当前条件变量上，等待读进程唤醒。

读过程：不断循环，如果有东西要读，获取当前缓冲区内的非空闲资源，如果没有非空闲空间，读操作就让睡在该条件变量上的写进程进行读操作，然后睡在当前条件变量上，等待读进程唤醒。


# 练习二 完成基于文件系统的执行程序机制的实现
这里和lab5的用户态切换，进程调度不一样。lab5是直接默认程序已经和操作系统一起被载入到内存中，然后在do_execve函数中调用iload_code，把新的代码覆盖进去。lab8的想法是这些代码需要从硬盘里面读。所以我们需要把那个binary改成从硬盘中读取。

具体实现参照注释，然后需要注意用户态的堆栈，这个在往年期末考试填代码的题里面也出现过。
Ustacktop这些里面哪里是argc，argv，需要注意的是argv是char**，所以要指两次。可以参考2015年的期末考试试卷，其中1的ascii码可以作为提示。

##硬链接与软链接方案设计概要

(1)硬链接
硬链接是指新的那个链接文件指向的也是原来的那个inode。在文件系统里面，文件的信息是存在inode里面，而不是文件本身，所以，删除原来的文件，只要inode还在，这个硬链接的内容还是可以读取。
我们的想法是，linux靠每个inode 不同的节点编号识别不同的inode。所以我们建立硬链接文件，只需要将新创建的inode编号和指向的inode编号设置相同即可，该inode的硬链接数+= 1
在删除的时候，需要首先判断删除后，inode的硬

(2)软链接

软链接指的是新建立的链接文件并不指向原来的inode，而是一个新的inode，但是文件的内容包括指向原来inode的地址。所以原链接删除的时候，和软链接文件无关，但是软链接文件就不能访问原来的inode了，类似于快捷方式。
所以实现方法就是首先查看这个inode有没有建立，如果没有建立，就建立一个新的inode，然后把原inode的地址作为内容存放在这个inode里。

